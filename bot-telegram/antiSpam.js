/**
 * Module Anti-Spam pour Bot Telegram
 * Pr√©vient le bannissement en impl√©mentant des mesures de s√©curit√©
 */

class AntiSpamSystem {
    constructor(options = {}) {
        // Configuration par d√©faut
        this.config = {
            // Limites de messages
            maxMessagesPerMinute: options.maxMessagesPerMinute || 20,
            maxMessagesPerHour: options.maxMessagesPerHour || 100,
            maxMessagesPerDay: options.maxMessagesPerDay || 500,
            
            // Cooldown entre messages (en ms)
            minCooldown: options.minCooldown || 1000,  // 1 seconde minimum
            maxCooldown: options.maxCooldown || 3000,  // 3 secondes maximum
            
            // D√©tection de flood
            floodThreshold: options.floodThreshold || 5,  // Messages identiques cons√©cutifs
            floodBanDuration: options.floodBanDuration || 300000,  // 5 minutes de ban temporaire
            
            // Comportement humain
            enableHumanBehavior: options.enableHumanBehavior !== false,
            typingDelay: options.typingDelay || 50,  // ms par caract√®re
            maxTypingDelay: options.maxTypingDelay || 5000,  // 5 secondes max
            
            // Limites par utilisateur
            userRateLimitMinute: options.userRateLimitMinute || 10,
            userRateLimitHour: options.userRateLimitHour || 50,
            
            // Mode debug
            debug: options.debug || false
        };
        
        // Stockage des donn√©es
        this.messageHistory = new Map();  // Historique des messages par utilisateur
        this.userActivity = new Map();    // Activit√© des utilisateurs
        this.bannedUsers = new Map();     // Utilisateurs temporairement bannis
        this.whitelist = new Set();       // Liste blanche
        this.blacklist = new Set();       // Liste noire permanente
        this.globalMessageCount = {
            minute: 0,
            hour: 0,
            day: 0,
            lastReset: {
                minute: Date.now(),
                hour: Date.now(),
                day: Date.now()
            }
        };
        
        // D√©marrer les timers de r√©initialisation
        this.startResetTimers();
    }
    
    /**
     * D√©marre les timers de r√©initialisation des compteurs
     */
    startResetTimers() {
        // R√©initialiser les compteurs par minute
        setInterval(() => {
            this.globalMessageCount.minute = 0;
            this.globalMessageCount.lastReset.minute = Date.now();
            this.cleanupOldData();
        }, 60000);  // Chaque minute
        
        // R√©initialiser les compteurs par heure
        setInterval(() => {
            this.globalMessageCount.hour = 0;
            this.globalMessageCount.lastReset.hour = Date.now();
        }, 3600000);  // Chaque heure
        
        // R√©initialiser les compteurs par jour
        setInterval(() => {
            this.globalMessageCount.day = 0;
            this.globalMessageCount.lastReset.day = Date.now();
        }, 86400000);  // Chaque jour
    }
    
    /**
     * Nettoie les anciennes donn√©es pour √©conomiser la m√©moire
     */
    cleanupOldData() {
        const now = Date.now();
        const oneHourAgo = now - 3600000;
        
        // Nettoyer l'historique des messages
        for (const [userId, history] of this.messageHistory.entries()) {
            const recentMessages = history.filter(msg => msg.timestamp > oneHourAgo);
            if (recentMessages.length === 0) {
                this.messageHistory.delete(userId);
            } else {
                this.messageHistory.set(userId, recentMessages);
            }
        }
        
        // Nettoyer les bans expir√©s
        for (const [userId, banTime] of this.bannedUsers.entries()) {
            if (banTime < now) {
                this.bannedUsers.delete(userId);
                if (this.config.debug) {
                    console.log(`üîì Utilisateur ${userId} d√©banni automatiquement`);
                }
            }
        }
    }
    
    /**
     * V√©rifie si un utilisateur peut envoyer un message
     * @param {number} userId - ID de l'utilisateur
     * @param {string} message - Contenu du message
     * @returns {object} - {allowed: boolean, reason: string, waitTime: number}
     */
    async canSendMessage(userId, message = '') {
        // V√©rifier la liste noire
        if (this.blacklist.has(userId)) {
            return {
                allowed: false,
                reason: 'Vous √™tes sur la liste noire.',
                waitTime: -1
            };
        }
        
        // V√©rifier la liste blanche (bypass toutes les restrictions)
        if (this.whitelist.has(userId)) {
            return { allowed: true, reason: 'whitelisted', waitTime: 0 };
        }
        
        // V√©rifier si l'utilisateur est temporairement banni
        const banExpiry = this.bannedUsers.get(userId);
        if (banExpiry && banExpiry > Date.now()) {
            const remainingTime = Math.ceil((banExpiry - Date.now()) / 1000);
            return {
                allowed: false,
                reason: `Vous √™tes temporairement restreint. R√©essayez dans ${remainingTime} secondes.`,
                waitTime: remainingTime
            };
        }
        
        // V√©rifier les limites globales
        const globalCheck = this.checkGlobalLimits();
        if (!globalCheck.allowed) {
            return globalCheck;
        }
        
        // V√©rifier les limites par utilisateur
        const userCheck = this.checkUserLimits(userId);
        if (!userCheck.allowed) {
            return userCheck;
        }
        
        // V√©rifier le flood (messages identiques)
        const floodCheck = this.checkFlood(userId, message);
        if (!floodCheck.allowed) {
            // Bannir temporairement pour flood
            this.bannedUsers.set(userId, Date.now() + this.config.floodBanDuration);
            return floodCheck;
        }
        
        // V√©rifier le cooldown
        const cooldownCheck = this.checkCooldown(userId);
        if (!cooldownCheck.allowed) {
            return cooldownCheck;
        }
        
        // Enregistrer le message
        this.recordMessage(userId, message);
        
        return { allowed: true, reason: 'ok', waitTime: 0 };
    }
    
    /**
     * V√©rifie les limites globales du bot
     */
    checkGlobalLimits() {
        // V√©rifier limite par minute
        if (this.globalMessageCount.minute >= this.config.maxMessagesPerMinute) {
            return {
                allowed: false,
                reason: 'Le bot est temporairement surcharg√©. R√©essayez dans quelques instants.',
                waitTime: 60
            };
        }
        
        // V√©rifier limite par heure
        if (this.globalMessageCount.hour >= this.config.maxMessagesPerHour) {
            return {
                allowed: false,
                reason: 'Limite horaire atteinte. R√©essayez plus tard.',
                waitTime: 3600
            };
        }
        
        // V√©rifier limite par jour
        if (this.globalMessageCount.day >= this.config.maxMessagesPerDay) {
            return {
                allowed: false,
                reason: 'Limite quotidienne atteinte. R√©essayez demain.',
                waitTime: 86400
            };
        }
        
        return { allowed: true };
    }
    
    /**
     * V√©rifie les limites par utilisateur
     */
    checkUserLimits(userId) {
        const userActivity = this.getUserActivity(userId);
        const now = Date.now();
        
        // Messages dans la derni√®re minute
        const recentMinute = userActivity.messages.filter(
            msg => msg.timestamp > now - 60000
        ).length;
        
        if (recentMinute >= this.config.userRateLimitMinute) {
            return {
                allowed: false,
                reason: 'Trop de messages. Veuillez patienter avant d\'envoyer un nouveau message.',
                waitTime: 60
            };
        }
        
        // Messages dans la derni√®re heure
        const recentHour = userActivity.messages.filter(
            msg => msg.timestamp > now - 3600000
        ).length;
        
        if (recentHour >= this.config.userRateLimitHour) {
            return {
                allowed: false,
                reason: 'Limite horaire atteinte. R√©essayez plus tard.',
                waitTime: 3600
            };
        }
        
        return { allowed: true };
    }
    
    /**
     * V√©rifie le flood (messages identiques r√©p√©t√©s)
     */
    checkFlood(userId, message) {
        if (!message) return { allowed: true };
        
        const history = this.messageHistory.get(userId) || [];
        const recentMessages = history.slice(-this.config.floodThreshold);
        
        // Compter les messages identiques cons√©cutifs
        let identicalCount = 0;
        for (let i = recentMessages.length - 1; i >= 0; i--) {
            if (recentMessages[i].content === message) {
                identicalCount++;
            } else {
                break;
            }
        }
        
        if (identicalCount >= this.config.floodThreshold - 1) {
            return {
                allowed: false,
                reason: 'D√©tection de spam. √âvitez d\'envoyer des messages identiques.',
                waitTime: this.config.floodBanDuration / 1000
            };
        }
        
        return { allowed: true };
    }
    
    /**
     * V√©rifie le cooldown entre messages
     */
    checkCooldown(userId) {
        const userActivity = this.getUserActivity(userId);
        const lastMessage = userActivity.lastMessageTime;
        
        if (!lastMessage) return { allowed: true };
        
        const elapsed = Date.now() - lastMessage;
        const requiredCooldown = this.getRandomCooldown();
        
        if (elapsed < requiredCooldown) {
            const waitTime = Math.ceil((requiredCooldown - elapsed) / 1000);
            return {
                allowed: false,
                reason: `Veuillez patienter ${waitTime} seconde(s) avant d'envoyer un nouveau message.`,
                waitTime: waitTime
            };
        }
        
        return { allowed: true };
    }
    
    /**
     * G√©n√®re un cooldown al√©atoire pour simuler un comportement humain
     */
    getRandomCooldown() {
        if (!this.config.enableHumanBehavior) {
            return this.config.minCooldown;
        }
        
        // Cooldown al√©atoire entre min et max
        return Math.floor(
            Math.random() * (this.config.maxCooldown - this.config.minCooldown) + 
            this.config.minCooldown
        );
    }
    
    /**
     * Calcule le d√©lai de frappe pour simuler un humain
     * @param {string} message - Le message √† "taper"
     * @returns {number} - D√©lai en millisecondes
     */
    getTypingDelay(message) {
        if (!this.config.enableHumanBehavior || !message) {
            return 0;
        }
        
        // Calculer le d√©lai bas√© sur la longueur du message
        const baseDelay = message.length * this.config.typingDelay;
        
        // Ajouter une variation al√©atoire (¬±20%)
        const variation = baseDelay * 0.2;
        const randomDelay = baseDelay + (Math.random() * variation * 2 - variation);
        
        // Limiter au maximum configur√©
        return Math.min(randomDelay, this.config.maxTypingDelay);
    }
    
    /**
     * Enregistre un message envoy√©
     */
    recordMessage(userId, message) {
        const now = Date.now();
        
        // Mettre √† jour l'historique des messages
        const history = this.messageHistory.get(userId) || [];
        history.push({
            content: message,
            timestamp: now
        });
        
        // Garder seulement les 100 derniers messages
        if (history.length > 100) {
            history.shift();
        }
        
        this.messageHistory.set(userId, history);
        
        // Mettre √† jour l'activit√© de l'utilisateur
        const userActivity = this.getUserActivity(userId);
        userActivity.lastMessageTime = now;
        userActivity.messages.push({ timestamp: now });
        
        // Garder seulement les messages de la derni√®re heure
        const oneHourAgo = now - 3600000;
        userActivity.messages = userActivity.messages.filter(
            msg => msg.timestamp > oneHourAgo
        );
        
        this.userActivity.set(userId, userActivity);
        
        // Incr√©menter les compteurs globaux
        this.globalMessageCount.minute++;
        this.globalMessageCount.hour++;
        this.globalMessageCount.day++;
        
        if (this.config.debug) {
            console.log(`üìä Message enregistr√© - User: ${userId}, Global: ${this.globalMessageCount.minute}/min`);
        }
    }
    
    /**
     * Obtient l'activit√© d'un utilisateur
     */
    getUserActivity(userId) {
        if (!this.userActivity.has(userId)) {
            this.userActivity.set(userId, {
                messages: [],
                lastMessageTime: null
            });
        }
        return this.userActivity.get(userId);
    }
    
    /**
     * Ajoute un utilisateur √† la liste blanche
     */
    addToWhitelist(userId) {
        this.whitelist.add(userId);
        this.blacklist.delete(userId);  // Retirer de la liste noire si pr√©sent
        if (this.config.debug) {
            console.log(`‚úÖ Utilisateur ${userId} ajout√© √† la liste blanche`);
        }
    }
    
    /**
     * Retire un utilisateur de la liste blanche
     */
    removeFromWhitelist(userId) {
        this.whitelist.delete(userId);
    }
    
    /**
     * Ajoute un utilisateur √† la liste noire
     */
    addToBlacklist(userId) {
        this.blacklist.add(userId);
        this.whitelist.delete(userId);  // Retirer de la liste blanche si pr√©sent
        if (this.config.debug) {
            console.log(`üö´ Utilisateur ${userId} ajout√© √† la liste noire`);
        }
    }
    
    /**
     * Retire un utilisateur de la liste noire
     */
    removeFromBlacklist(userId) {
        this.blacklist.delete(userId);
    }
    
    /**
     * R√©initialise les donn√©es d'un utilisateur
     */
    resetUser(userId) {
        this.messageHistory.delete(userId);
        this.userActivity.delete(userId);
        this.bannedUsers.delete(userId);
    }
    
    /**
     * Obtient les statistiques du syst√®me
     */
    getStats() {
        return {
            globalMessages: {
                minute: this.globalMessageCount.minute,
                hour: this.globalMessageCount.hour,
                day: this.globalMessageCount.day
            },
            activeUsers: this.userActivity.size,
            bannedUsers: this.bannedUsers.size,
            whitelistedUsers: this.whitelist.size,
            blacklistedUsers: this.blacklist.size,
            limits: {
                perMinute: this.config.maxMessagesPerMinute,
                perHour: this.config.maxMessagesPerHour,
                perDay: this.config.maxMessagesPerDay
            }
        };
    }
    
    /**
     * Middleware pour int√©gration facile avec node-telegram-bot-api
     */
    createMiddleware(bot) {
        return async (msg) => {
            const userId = msg.from.id;
            const messageText = msg.text || '';
            
            // V√©rifier si l'utilisateur peut envoyer un message
            const check = await this.canSendMessage(userId, messageText);
            
            if (!check.allowed) {
                // Envoyer un message d'avertissement √† l'utilisateur
                try {
                    await bot.sendMessage(
                        msg.chat.id,
                        `‚ö†Ô∏è ${check.reason}`,
                        {
                            reply_to_message_id: msg.message_id,
                            parse_mode: 'HTML'
                        }
                    );
                } catch (error) {
                    console.error('Erreur envoi avertissement anti-spam:', error);
                }
                
                // Retourner false pour indiquer que le message ne doit pas √™tre trait√©
                return false;
            }
            
            // Si comportement humain activ√©, simuler la frappe
            if (this.config.enableHumanBehavior) {
                const typingDelay = this.getTypingDelay(messageText);
                if (typingDelay > 0) {
                    await bot.sendChatAction(msg.chat.id, 'typing');
                    await new Promise(resolve => setTimeout(resolve, typingDelay));
                }
            }
            
            // Retourner true pour indiquer que le message peut √™tre trait√©
            return true;
        };
    }
}

module.exports = AntiSpamSystem;