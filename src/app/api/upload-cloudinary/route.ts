import { NextRequest, NextResponse } from 'next/server';

export const maxDuration = 300;
export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ Upload Cloudinary LANATION d√©marr√©...');
    
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json({ error: 'Aucun fichier fourni' }, { status: 400 });
    }

    console.log('üìÅ Fichier re√ßu:', {
      name: file.name,
      type: file.type,
      size: Math.round(file.size / 1024 / 1024 * 100) / 100 + 'MB'
    });

    // D√©terminer le type r√©el du fichier bas√© sur l'extension si le type MIME est vide ou incorrect
    let fileType = file.type;
    const fileName = file.name.toLowerCase();
    
    // Gestion sp√©ciale pour les fichiers iPhone
    if (!fileType || fileType === 'application/octet-stream' || fileType === '') {
      console.log('‚ö†Ô∏è Type MIME manquant, d√©tection par extension...');
      
      if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
        fileType = 'image/jpeg';
      } else if (fileName.endsWith('.png')) {
        fileType = 'image/png';
      } else if (fileName.endsWith('.webp')) {
        fileType = 'image/webp';
      } else if (fileName.endsWith('.gif')) {
        fileType = 'image/gif';
      } else if (fileName.endsWith('.heic') || fileName.endsWith('.heif')) {
        fileType = 'image/heic';
      } else if (fileName.endsWith('.mp4')) {
        fileType = 'video/mp4';
      } else if (fileName.endsWith('.mov')) {
        fileType = 'video/quicktime';
      } else if (fileName.endsWith('.3gp') || fileName.endsWith('.3g2')) {
        fileType = 'video/3gpp';
      } else if (fileName.endsWith('.webm')) {
        fileType = 'video/webm';
      } else if (fileName.endsWith('.avi')) {
        fileType = 'video/x-msvideo';
      } else if (fileName.endsWith('.mkv')) {
        fileType = 'video/x-matroska';
      }
      
      console.log('üìã Type d√©tect√©:', fileType);
    }

    // Accepter TOUS les fichiers avec extensions valides
    const validExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.heic', '.heif', '.mp4', '.mov', '.avi', '.3gp', '.3g2', '.webm', '.mkv'];
    const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
    
    if (!validExtensions.includes(fileExtension)) {
      return NextResponse.json({ 
        error: `Extension non support√©e: ${fileExtension}. Extensions accept√©es: ${validExtensions.join(', ')}` 
      }, { status: 400 });
    }
    
    // D√©terminer si c'est une vid√©o
    const videoExtensions = ['.mp4', '.mov', '.avi', '.3gp', '.3g2', '.webm', '.mkv'];
    const isVideo = videoExtensions.includes(fileExtension) || fileType.startsWith('video/');

    const maxSize = isVideo ? 2 * 1024 * 1024 * 1024 : 50 * 1024 * 1024; // 2GB pour vid√©os (longues et haute qualit√©), 50MB pour images
    
    if (file.size > maxSize) {
      return NextResponse.json({ 
        error: `Fichier trop volumineux: ${Math.round(file.size / 1024 / 1024)}MB. Maximum ${isVideo ? '2GB' : '50MB'}` 
      }, { status: 400 });
    }

    // Convertir le fichier en buffer
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // Pour les fichiers HEIC/HEIF, on doit utiliser un type MIME support√© par Cloudinary
    let uploadType = fileType;
    if (fileType === 'image/heic' || fileType === 'image/heif' || fileExtension === '.heic' || fileExtension === '.heif') {
      // Cloudinary peut g√©rer HEIC mais on doit utiliser le bon type
      uploadType = 'image/jpeg'; // Cloudinary convertira automatiquement
      console.log('üîÑ Format HEIC/HEIF d√©tect√© - Cloudinary va convertir en JPEG');
    }

    // Upload vers Cloudinary avec preset unsigned
    const uploadResult = await new Promise((resolve, reject) => {
      // Cr√©er un FormData pour l'upload
      const uploadFormData = new FormData();
      
      // Ajouter le fichier avec le bon type MIME
      const blob = new Blob([buffer], { type: uploadType });
      uploadFormData.append('file', blob, file.name);
      
      // Ajouter les param√®tres du preset - TR√àS IMPORTANT
      uploadFormData.append('upload_preset', 'lntdl_media');
      
      // Pour les fichiers HEIC, demander une conversion automatique
      if (fileExtension === '.heic' || fileExtension === '.heif') {
        uploadFormData.append('format', 'jpg');
      }
      
      console.log('üì§ Upload vers Cloudinary avec preset:', 'lntdl_media', 'Type:', uploadType);

      // Upload direct vers Cloudinary
      fetch(`https://api.cloudinary.com/v1_1/dwez3etsh/${isVideo ? 'video' : 'image'}/upload`, {
        method: 'POST',
        body: uploadFormData
      })
      .then(response => {
        console.log('üì• R√©ponse Cloudinary:', response.status, response.statusText);
        if (!response.ok) {
          return response.text().then(errorText => {
            console.error('‚ùå Erreur HTTP:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          });
        }
        return response.json();
      })
      .then(result => {
        if (result.error) {
          console.error('‚ùå Erreur Cloudinary:', result.error);
          reject(new Error(result.error.message || 'Erreur upload'));
        } else {
          console.log('‚úÖ Upload r√©ussi:', result.secure_url);
          resolve(result);
        }
      })
      .catch(error => {
        console.error('‚ùå Erreur fetch:', error);
        reject(error);
      });
    });

    const result = uploadResult as any;
    
    return NextResponse.json({
      url: result.secure_url,
      public_id: result.public_id,
      type: isVideo ? 'video' : 'image',
      filename: file.name,
      size: file.size,
      format: result.format // Format final apr√®s conversion
    });

  } catch (error) {
    console.error('‚ùå Erreur upload:', error);
    return NextResponse.json({ 
      error: 'Erreur lors de l\'upload',
      details: error instanceof Error ? error.message : 'Erreur inconnue'
    }, { status: 500 });
  }
}